/*
 * This file is generated by jOOQ.
 */
package com.wuda.foundation.notification.impl.jooq.generation;


import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationCategory;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationDefinitionContent;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationDefinitionCore;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationDefinitionObserver;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationDefinitionObserverrExpandSnapshot;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationDefinitionSendMethod;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationDifinitionGroupRelation;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationInstanceContent;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationInstanceSendHistory;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationInstanceTrace;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationSendMethod;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationTemplate;


/**
 * Convenience access to all tables in foundation_notification
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class Tables {

    /**
     * 分类
     */
    public static final NotificationCategory NOTIFICATION_CATEGORY = NotificationCategory.NOTIFICATION_CATEGORY;

    /**
     * 定义通知的内容。【一个很重要的规则是】同一个定义，可以反复发送通知（比如，你是一个系统管理员，当主机cpu超过50%的时候，就发送通知给你，这个时候，你可以声明一个通知定义，然后只要主机cpu超过50，就通过这个定义发送消息给你，这种场景下，通知定义是一次性的，但是通过这个定义，会发送无数条通知），因此，每当使用这个定义发送通知时，就可以为这个定义声明发送的内容。
     */
    public static final NotificationDefinitionContent NOTIFICATION_DEFINITION_CONTENT = NotificationDefinitionContent.NOTIFICATION_DEFINITION_CONTENT;

    /**
     * 用于定义通知。这个就好像是Java中的Class，实例（Object）通过Class生成；同样的，我们先定义通知的内容，发送方式，使用的模板，接收人等等信息，然后根据定义产生具体的通知。。表中的每条记录都好像Java中定义的一个Class一样。
     */
    public static final NotificationDefinitionCore NOTIFICATION_DEFINITION_CORE = NotificationDefinitionCore.NOTIFICATION_DEFINITION_CORE;

    /**
     * 定义通知的观察者，用于接收或者查看通知
     */
    public static final NotificationDefinitionObserver NOTIFICATION_DEFINITION_OBSERVER = NotificationDefinitionObserver.NOTIFICATION_DEFINITION_OBSERVER;

    /**
     * 接收者如果是“全部”，“莫某部门”这样的一类用户时，在接收者主表保存“全部”这样类型的接收者时，将当时那个瞬间“全部”的用户展开来保存到这个表中，比如当时整个公司全部只有20个人，则在这个表展开来就有20条记录，后面如果公司再新进新人，则新人不包含。
     */
    public static final NotificationDefinitionObserverrExpandSnapshot NOTIFICATION_DEFINITION_OBSERVERR_EXPAND_SNAPSHOT = NotificationDefinitionObserverrExpandSnapshot.NOTIFICATION_DEFINITION_OBSERVERR_EXPAND_SNAPSHOT;

    /**
     * 定义通知发表的方式，比如通过邮件，公告发表
     */
    public static final NotificationDefinitionSendMethod NOTIFICATION_DEFINITION_SEND_METHOD = NotificationDefinitionSendMethod.NOTIFICATION_DEFINITION_SEND_METHOD;

    /**
     * 通知定义所属的组
     */
    public static final NotificationDifinitionGroupRelation NOTIFICATION_DIFINITION_GROUP_RELATION = NotificationDifinitionGroupRelation.NOTIFICATION_DIFINITION_GROUP_RELATION;

    /**
     * 代表一条实际已经发送的通知。通知模块的设计，不局限于发给用户，或者从用户发出来，任何实体都可以发送和接收，比如service A可以发送给service B，因此会有receiver type和sender type的设计。同样的内容，可以通过多种方式发送，比如通过邮件，短信发送同样的内容，因此发送方式不放到这个表中，这样的好处是不同的发送方式可以指向（共享）同一个通知。
     */
    public static final NotificationInstanceContent NOTIFICATION_INSTANCE_CONTENT = NotificationInstanceContent.NOTIFICATION_INSTANCE_CONTENT;

    /**
     * 通知发送历史
     */
    public static final NotificationInstanceSendHistory NOTIFICATION_INSTANCE_SEND_HISTORY = NotificationInstanceSendHistory.NOTIFICATION_INSTANCE_SEND_HISTORY;

    /**
     * 通知的追踪信息，比如是否被接收者阅读
     */
    public static final NotificationInstanceTrace NOTIFICATION_INSTANCE_TRACE = NotificationInstanceTrace.NOTIFICATION_INSTANCE_TRACE;

    /**
     * 通知发表的方式，比如通过email，sms发送，很多国外的术语中，database表示保存到本地数据库表，也就是通常所说的站内信
     */
    public static final NotificationSendMethod NOTIFICATION_SEND_METHOD = NotificationSendMethod.NOTIFICATION_SEND_METHOD;

    /**
     * 通知内容的模板
     */
    public static final NotificationTemplate NOTIFICATION_TEMPLATE = NotificationTemplate.NOTIFICATION_TEMPLATE;
}
