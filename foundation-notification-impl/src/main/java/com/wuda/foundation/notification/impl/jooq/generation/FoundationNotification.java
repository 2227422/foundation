/*
 * This file is generated by jOOQ.
 */
package com.wuda.foundation.notification.impl.jooq.generation;


import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationCategory;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationDefinitionContent;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationDefinitionCore;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationDefinitionObserver;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationDefinitionObserverrExpandSnapshot;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationDefinitionSendMethod;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationDifinitionGroupRelationship;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationInstanceContent;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationInstanceSendHistory;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationInstanceTrace;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationSendMethod;
import com.wuda.foundation.notification.impl.jooq.generation.tables.NotificationTemplate;

import java.util.Arrays;
import java.util.List;

import org.jooq.Catalog;
import org.jooq.Table;
import org.jooq.impl.SchemaImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class FoundationNotification extends SchemaImpl {

    private static final long serialVersionUID = 632244308;

    /**
     * The reference instance of <code>foundation_notification</code>
     */
    public static final FoundationNotification FOUNDATION_NOTIFICATION = new FoundationNotification();

    /**
     * 分类
     */
    public final NotificationCategory NOTIFICATION_CATEGORY = NotificationCategory.NOTIFICATION_CATEGORY;

    /**
     * 定义通知的内容。【一个很重要的规则是】同一个定义，可以反复发送通知（比如，你是一个系统管理员，当主机cpu超过50%的时候，就发送通知给你，这个时候，你可以声明一个通知定义，然后只要主机cpu超过50，就通过这个定义发送消息给你，这种场景下，通知定义是一次性的，但是通过这个定义，会发送无数条通知），因此，每当使用这个定义发送通知时，就可以为这个定义声明发送的内容。
     */
    public final NotificationDefinitionContent NOTIFICATION_DEFINITION_CONTENT = NotificationDefinitionContent.NOTIFICATION_DEFINITION_CONTENT;

    /**
     * 用于定义通知。这个就好像是Java中的Class，实例（Object）通过Class生成；同样的，我们先定义通知的内容，发送方式，使用的模板，接收人等等信息，然后根据定义产生具体的通知。。表中的每条记录都好像Java中定义的一个Class一样。
     */
    public final NotificationDefinitionCore NOTIFICATION_DEFINITION_CORE = NotificationDefinitionCore.NOTIFICATION_DEFINITION_CORE;

    /**
     * 定义通知的观察者，用于接收或者查看通知
     */
    public final NotificationDefinitionObserver NOTIFICATION_DEFINITION_OBSERVER = NotificationDefinitionObserver.NOTIFICATION_DEFINITION_OBSERVER;

    /**
     * 接收者如果是“全部”，“莫某部门”这样的一类用户时，在接收者主表保存“全部”这样类型的接收者时，将当时那个瞬间“全部”的用户展开来保存到这个表中，比如当时整个公司全部只有20个人，则在这个表展开来就有20条记录，后面如果公司再新进新人，则新人不包含。
     */
    public final NotificationDefinitionObserverrExpandSnapshot NOTIFICATION_DEFINITION_OBSERVERR_EXPAND_SNAPSHOT = NotificationDefinitionObserverrExpandSnapshot.NOTIFICATION_DEFINITION_OBSERVERR_EXPAND_SNAPSHOT;

    /**
     * 定义通知发表的方式，比如通过邮件，公告发表
     */
    public final NotificationDefinitionSendMethod NOTIFICATION_DEFINITION_SEND_METHOD = NotificationDefinitionSendMethod.NOTIFICATION_DEFINITION_SEND_METHOD;

    /**
     * 通知定义所属的组
     */
    public final NotificationDifinitionGroupRelationship NOTIFICATION_DIFINITION_GROUP_RELATIONSHIP = NotificationDifinitionGroupRelationship.NOTIFICATION_DIFINITION_GROUP_RELATIONSHIP;

    /**
     * 代表一条实际已经发送的通知。通知模块的设计，不局限于发给用户，或者从用户发出来，任何实体都可以发送和接收，比如service A可以发送给service B，因此会有receiver type和sender type的设计。同样的内容，可以通过多种方式发送，比如通过邮件，短信发送同样的内容，因此发送方式不放到这个表中，这样的好处是不同的发送方式可以指向（共享）同一个通知。
     */
    public final NotificationInstanceContent NOTIFICATION_INSTANCE_CONTENT = NotificationInstanceContent.NOTIFICATION_INSTANCE_CONTENT;

    /**
     * 通知发送历史
     */
    public final NotificationInstanceSendHistory NOTIFICATION_INSTANCE_SEND_HISTORY = NotificationInstanceSendHistory.NOTIFICATION_INSTANCE_SEND_HISTORY;

    /**
     * 通知的追踪信息，比如是否被接收者阅读
     */
    public final NotificationInstanceTrace NOTIFICATION_INSTANCE_TRACE = NotificationInstanceTrace.NOTIFICATION_INSTANCE_TRACE;

    /**
     * 通知发表的方式，比如通过email，sms发送，很多国外的术语中，database表示保存到本地数据库表，也就是通常所说的站内信；但是像公告这种类型的通知，是不需要真正发送到具接收者的，它并没有发送的概念，因此使用post而不是send这个单词。
     */
    public final NotificationSendMethod NOTIFICATION_SEND_METHOD = NotificationSendMethod.NOTIFICATION_SEND_METHOD;

    /**
     * 通知内容的模板
     */
    public final NotificationTemplate NOTIFICATION_TEMPLATE = NotificationTemplate.NOTIFICATION_TEMPLATE;

    /**
     * No further instances allowed
     */
    private FoundationNotification() {
        super("foundation_notification", null);
    }


    @Override
    public Catalog getCatalog() {
        return DefaultCatalog.DEFAULT_CATALOG;
    }

    @Override
    public final List<Table<?>> getTables() {
        return Arrays.<Table<?>>asList(
            NotificationCategory.NOTIFICATION_CATEGORY,
            NotificationDefinitionContent.NOTIFICATION_DEFINITION_CONTENT,
            NotificationDefinitionCore.NOTIFICATION_DEFINITION_CORE,
            NotificationDefinitionObserver.NOTIFICATION_DEFINITION_OBSERVER,
            NotificationDefinitionObserverrExpandSnapshot.NOTIFICATION_DEFINITION_OBSERVERR_EXPAND_SNAPSHOT,
            NotificationDefinitionSendMethod.NOTIFICATION_DEFINITION_SEND_METHOD,
            NotificationDifinitionGroupRelationship.NOTIFICATION_DIFINITION_GROUP_RELATIONSHIP,
            NotificationInstanceContent.NOTIFICATION_INSTANCE_CONTENT,
            NotificationInstanceSendHistory.NOTIFICATION_INSTANCE_SEND_HISTORY,
            NotificationInstanceTrace.NOTIFICATION_INSTANCE_TRACE,
            NotificationSendMethod.NOTIFICATION_SEND_METHOD,
            NotificationTemplate.NOTIFICATION_TEMPLATE);
    }
}
