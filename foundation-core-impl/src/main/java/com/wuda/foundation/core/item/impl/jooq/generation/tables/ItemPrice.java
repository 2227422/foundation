/*
 * This file is generated by jOOQ.
 */
package com.wuda.foundation.core.item.impl.jooq.generation.tables;


import com.wuda.foundation.core.item.impl.jooq.generation.FoundationItem;
import com.wuda.foundation.core.item.impl.jooq.generation.Indexes;
import com.wuda.foundation.core.item.impl.jooq.generation.Keys;
import com.wuda.foundation.core.item.impl.jooq.generation.tables.records.ItemPriceRecord;
import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.Index;
import org.jooq.Name;
import org.jooq.Record;
import org.jooq.Row10;
import org.jooq.Schema;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.TableImpl;
import org.jooq.types.UInteger;
import org.jooq.types.ULong;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;


/**
 * 物品级别的价格，在价格体系中处于最低级别，当其他价格都没有设置的，取该价格。比如：当物品规格有自己的价格时，优先使用规格的价格。同时需要特别注意的是：同一个物品只能有一条记录，代表在没有任何业务的情况下，该物品使用的价格。随着业务的发展，该物品可能需要其他价格，这些价格必须保存到具体的业务相关的表中，也就是说该表不保存任何与业务相关的价格。
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class ItemPrice extends TableImpl<ItemPriceRecord> {

    private static final long serialVersionUID = -1885930064;

    /**
     * The reference instance of <code>foundation_item.item_price</code>
     */
    public static final ItemPrice ITEM_PRICE = new ItemPrice();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<ItemPriceRecord> getRecordType() {
        return ItemPriceRecord.class;
    }

    /**
     * The column <code>foundation_item.item_price.item_price_id</code>. 主键
     */
    public final TableField<ItemPriceRecord, ULong> ITEM_PRICE_ID = createField(DSL.name("item_price_id"), org.jooq.impl.SQLDataType.BIGINTUNSIGNED.nullable(false), this, "主键");

    /**
     * The column <code>foundation_item.item_price.item_id</code>.
     */
    public final TableField<ItemPriceRecord, ULong> ITEM_ID = createField(DSL.name("item_id"), org.jooq.impl.SQLDataType.BIGINTUNSIGNED.nullable(false), this, "");

    /**
     * The column <code>foundation_item.item_price.item_variation_id</code>.
     */
    public final TableField<ItemPriceRecord, ULong> ITEM_VARIATION_ID = createField(DSL.name("item_variation_id"), org.jooq.impl.SQLDataType.BIGINTUNSIGNED.nullable(false).defaultValue(DSL.inline("0", org.jooq.impl.SQLDataType.BIGINTUNSIGNED)), this, "");

    /**
     * The column <code>foundation_item.item_price.purchase_price</code>. 购买价格。单位是分。定义很明确，就是用户购买商品时，实实在在支付的金额。
价格种类可能很多，比如零售价，市场价等等，名词很多，但是这些价格不一定是用户最后
实际支付的价格，而且在实际业务中很容易出现【如果是这个业务就拿Ａ价格作为购买价格，
如果是那个业务又拿Ｂ价格作为购买价格】，是当我们认真思考会发现，不管怎么样，
用户最终总是有一个支付的金额，这个字段就是保存这个价格。其他业务可能会有自身业务相关的购买价格，
比如做活动时，通常叫活动价，但是换个思维，这个活动价也就是当前活动的购买价，
因此在相关表中保存价格时名称必须和这个字段一样，避免名称太多，造成混乱。
     */
    public final TableField<ItemPriceRecord, UInteger> PURCHASE_PRICE = createField(DSL.name("purchase_price"), org.jooq.impl.SQLDataType.INTEGERUNSIGNED.nullable(false), this, "购买价格。单位是分。定义很明确，就是用户购买商品时，实实在在支付的金额。\n价格种类可能很多，比如零售价，市场价等等，名词很多，但是这些价格不一定是用户最后\n实际支付的价格，而且在实际业务中很容易出现【如果是这个业务就拿Ａ价格作为购买价格，\n如果是那个业务又拿Ｂ价格作为购买价格】，是当我们认真思考会发现，不管怎么样，\n用户最终总是有一个支付的金额，这个字段就是保存这个价格。其他业务可能会有自身业务相关的购买价格，\n比如做活动时，通常叫活动价，但是换个思维，这个活动价也就是当前活动的购买价，\n因此在相关表中保存价格时名称必须和这个字段一样，避免名称太多，造成混乱。");

    /**
     * The column <code>foundation_item.item_price.line_throuth_price</code>. 划线价。单位是分。 定义很明确， 就是页面显示的那个划线后的价格， 价格种类可能很多，
比如零售价，市场价等等，名词很多，但是这些价格哪一个是用于划线的呢？ 如果不明确定义， 就会出现
【如果是这个业务就拿Ａ价格划线，如果是那个业务又拿Ｂ价格划线】，为了避免出现这些情况,在这里
统一定义，其他业务可能会有自身业务相关的划线价格，比如做活动时，用于划线的价格可能叫做‘原价’，
但是换个思维，这个'原价'也就是当前活动的划线价，因此在相关表中保存价格时名称必须和这个字段一样，
避免名称太多，造成混乱。line through，来自于CSS中的划线样式。
     */
    public final TableField<ItemPriceRecord, UInteger> LINE_THROUTH_PRICE = createField(DSL.name("line_throuth_price"), org.jooq.impl.SQLDataType.INTEGERUNSIGNED.nullable(false), this, "划线价。单位是分。 定义很明确， 就是页面显示的那个划线后的价格， 价格种类可能很多，\n比如零售价，市场价等等，名词很多，但是这些价格哪一个是用于划线的呢？ 如果不明确定义， 就会出现\n【如果是这个业务就拿Ａ价格划线，如果是那个业务又拿Ｂ价格划线】，为了避免出现这些情况,在这里\n统一定义，其他业务可能会有自身业务相关的划线价格，比如做活动时，用于划线的价格可能叫做‘原价’，\n但是换个思维，这个'原价'也就是当前活动的划线价，因此在相关表中保存价格时名称必须和这个字段一样，\n避免名称太多，造成混乱。line through，来自于CSS中的划线样式。");

    /**
     * The column <code>foundation_item.item_price.create_time</code>.
     */
    public final TableField<ItemPriceRecord, LocalDateTime> CREATE_TIME = createField(DSL.name("create_time"), org.jooq.impl.SQLDataType.LOCALDATETIME.nullable(false).defaultValue(DSL.field("CURRENT_TIMESTAMP", org.jooq.impl.SQLDataType.LOCALDATETIME)), this, "");

    /**
     * The column <code>foundation_item.item_price.create_user_id</code>.
     */
    public final TableField<ItemPriceRecord, ULong> CREATE_USER_ID = createField(DSL.name("create_user_id"), org.jooq.impl.SQLDataType.BIGINTUNSIGNED.nullable(false), this, "");

    /**
     * The column <code>foundation_item.item_price.last_modify_time</code>.
     */
    public final TableField<ItemPriceRecord, LocalDateTime> LAST_MODIFY_TIME = createField(DSL.name("last_modify_time"), org.jooq.impl.SQLDataType.LOCALDATETIME.nullable(false).defaultValue(DSL.field("CURRENT_TIMESTAMP", org.jooq.impl.SQLDataType.LOCALDATETIME)), this, "");

    /**
     * The column <code>foundation_item.item_price.last_modify_user_id</code>.
     */
    public final TableField<ItemPriceRecord, ULong> LAST_MODIFY_USER_ID = createField(DSL.name("last_modify_user_id"), org.jooq.impl.SQLDataType.BIGINTUNSIGNED.nullable(false), this, "");

    /**
     * The column <code>foundation_item.item_price.is_deleted</code>.
     */
    public final TableField<ItemPriceRecord, ULong> IS_DELETED = createField(DSL.name("is_deleted"), org.jooq.impl.SQLDataType.BIGINTUNSIGNED.nullable(false).defaultValue(DSL.inline("0", org.jooq.impl.SQLDataType.BIGINTUNSIGNED)), this, "");

    /**
     * Create a <code>foundation_item.item_price</code> table reference
     */
    public ItemPrice() {
        this(DSL.name("item_price"), null);
    }

    /**
     * Create an aliased <code>foundation_item.item_price</code> table reference
     */
    public ItemPrice(String alias) {
        this(DSL.name(alias), ITEM_PRICE);
    }

    /**
     * Create an aliased <code>foundation_item.item_price</code> table reference
     */
    public ItemPrice(Name alias) {
        this(alias, ITEM_PRICE);
    }

    private ItemPrice(Name alias, Table<ItemPriceRecord> aliased) {
        this(alias, aliased, null);
    }

    private ItemPrice(Name alias, Table<ItemPriceRecord> aliased, Field<?>[] parameters) {
        super(alias, null, aliased, parameters, DSL.comment("物品级别的价格，在价格体系中处于最低级别，当其他价格都没有设置的，取该价格。比如：当物品规格有自己的价格时，优先使用规格的价格。同时需要特别注意的是：同一个物品只能有一条记录，代表在没有任何业务的情况下，该物品使用的价格。随着业务的发展，该物品可能需要其他价格，这些价格必须保存到具体的业务相关的表中，也就是说该表不保存任何与业务相关的价格。"), TableOptions.table());
    }

    public <O extends Record> ItemPrice(Table<O> child, ForeignKey<O, ItemPriceRecord> key) {
        super(child, key, ITEM_PRICE);
    }

    @Override
    public Schema getSchema() {
        return FoundationItem.FOUNDATION_ITEM;
    }

    @Override
    public List<Index> getIndexes() {
        return Arrays.<Index>asList(Indexes.ITEM_PRICE_FK_ITEM_VARIATION_ID, Indexes.ITEM_PRICE_IDX_ITEM_ID);
    }

    @Override
    public UniqueKey<ItemPriceRecord> getPrimaryKey() {
        return Keys.KEY_ITEM_PRICE_PRIMARY;
    }

    @Override
    public List<UniqueKey<ItemPriceRecord>> getKeys() {
        return Arrays.<UniqueKey<ItemPriceRecord>>asList(Keys.KEY_ITEM_PRICE_PRIMARY, Keys.KEY_ITEM_PRICE_IDX_UNIQUE);
    }

    @Override
    public ItemPrice as(String alias) {
        return new ItemPrice(DSL.name(alias), this);
    }

    @Override
    public ItemPrice as(Name alias) {
        return new ItemPrice(alias, this);
    }

    /**
     * Rename this table
     */
    @Override
    public ItemPrice rename(String name) {
        return new ItemPrice(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public ItemPrice rename(Name name) {
        return new ItemPrice(name, null);
    }

    // -------------------------------------------------------------------------
    // Row10 type methods
    // -------------------------------------------------------------------------

    @Override
    public Row10<ULong, ULong, ULong, UInteger, UInteger, LocalDateTime, ULong, LocalDateTime, ULong, ULong> fieldsRow() {
        return (Row10) super.fieldsRow();
    }
}
